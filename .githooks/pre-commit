#!/bin/bash

# Git Pre-Commit Hook to Prevent Secret Leaks
# This hook scans staged files for potential secrets before committing

echo "üîç Scanning for secrets before commit..."

# Colors for output
RED='\033[0;31m'
YELLOW='\033[1;33m'
GREEN='\033[0;32m'
NC='\033[0m' # No Color

# Flag to track if secrets were found
SECRETS_FOUND=false

# Get list of staged files
STAGED_FILES=$(git diff --cached --name-only --diff-filter=ACM)

if [ -z "$STAGED_FILES" ]; then
    echo -e "${GREEN}‚úÖ No staged files to scan${NC}"
    exit 0
fi

echo "üìÅ Scanning staged files:"
echo "$STAGED_FILES"
echo ""

# Secret patterns to detect (using simple arrays to avoid syntax issues)
check_google_api_key() {
    echo "$1" | grep -qE "AIza[0-9A-Za-z_-]{35}"
}

check_aws_access_key() {
    echo "$1" | grep -qE "AKIA[0-9A-Z]{16}"
}

check_jwt_token() {
    echo "$1" | grep -qE "eyJ[A-Za-z0-9_-]*\.[A-Za-z0-9_-]*\.[A-Za-z0-9_-]*"
}

check_private_key() {
    echo "$1" | grep -qE "-----BEGIN [A-Z ]*PRIVATE KEY-----"
}

check_stripe_secret() {
    echo "$1" | grep -qE "sk_[a-z]*_[A-Za-z0-9]{24,}"
}

check_openai_key() {
    echo "$1" | grep -qE "sk-[A-Za-z0-9]{48,}"
}

# Function to check if content is an exception
is_exception() {
    local content="$1"

    # Check for placeholder patterns
    if echo "$content" | grep -qE "(YOUR_.*_KEY_HERE|YOUR_.*_TOKEN_HERE|REPLACE_WITH_|EXAMPLE_|DEMO_)"; then
        return 0
    fi

    # Check for environment variable references
    if echo "$content" | grep -qE "(process\.env\.|Deno\.env\.get|\$\{.*\})"; then
        return 0
    fi

    # Check for test/mock patterns
    if echo "$content" | grep -qE "(test[_-].*key|mock[_-].*key|fake[_-].*key)"; then
        return 0
    fi

    # Check for comments
    if echo "$content" | grep -qE "(# This is a public|// Public|Replace with your actual)"; then
        return 0
    fi

    # Specific old example key (safe to commit in docs)
    if echo "$content" | grep -qF "AIzaSyBX5y8P2dE8-1MqF3CqDXO_K3UPMFNpJ_M"; then
        return 0
    fi

    return 1
}

# Function to report secret found
report_secret() {
    local file="$1"
    local type="$2"
    local match="$3"

    echo -e "${RED}‚ùå POTENTIAL SECRET DETECTED${NC}"
    echo "   File: $file"
    echo "   Type: $type"
    echo "   Pattern: ${match:0:40}..."
    echo ""
    SECRETS_FOUND=true
}

# Scan each staged file
for file in $STAGED_FILES; do
    # Skip binary files
    if file "$file" | grep -q "binary" 2>/dev/null; then
        continue
    fi

    # Skip if file doesn't exist (deleted files)
    if [ ! -f "$file" ]; then
        continue
    fi

    echo "üîç Scanning: $file"

    # Get the staged content (what's being committed)
    CONTENT=$(git diff --cached "$file")

    # Skip if no content
    if [ -z "$CONTENT" ]; then
        continue
    fi

    # Check for Google API keys
    while IFS= read -r line; do
        if [[ "$line" =~ ^\+ ]] && check_google_api_key "$line"; then
            match=$(echo "$line" | grep -oE "AIza[0-9A-Za-z_-]{35}")
            if [ -n "$match" ] && ! is_exception "$line"; then
                report_secret "$file" "Google API Key" "$match"
            fi
        fi
    done <<< "$CONTENT"

    # Check for AWS keys
    while IFS= read -r line; do
        if [[ "$line" =~ ^\+ ]] && check_aws_access_key "$line"; then
            match=$(echo "$line" | grep -oE "AKIA[0-9A-Z]{16}")
            if [ -n "$match" ] && ! is_exception "$line"; then
                report_secret "$file" "AWS Access Key" "$match"
            fi
        fi
    done <<< "$CONTENT"

    # Check for JWT tokens
    while IFS= read -r line; do
        if [[ "$line" =~ ^\+ ]] && check_jwt_token "$line"; then
            match=$(echo "$line" | grep -oE "eyJ[A-Za-z0-9_-]*\.[A-Za-z0-9_-]*\.[A-Za-z0-9_-]*")
            if [ -n "$match" ] && ! is_exception "$line"; then
                report_secret "$file" "JWT Token" "$match"
            fi
        fi
    done <<< "$CONTENT"

    # Check for private keys
    while IFS= read -r line; do
        if [[ "$line" =~ ^\+ ]] && check_private_key "$line"; then
            if ! is_exception "$line"; then
                report_secret "$file" "Private Key" "-----BEGIN PRIVATE KEY-----"
            fi
        fi
    done <<< "$CONTENT"

    # Check for Stripe secret keys
    while IFS= read -r line; do
        if [[ "$line" =~ ^\+ ]] && check_stripe_secret "$line"; then
            match=$(echo "$line" | grep -oE "sk_[a-z]*_[A-Za-z0-9]{24,}")
            if [ -n "$match" ] && ! is_exception "$line"; then
                report_secret "$file" "Stripe Secret Key" "$match"
            fi
        fi
    done <<< "$CONTENT"

    # Check for OpenAI keys
    while IFS= read -r line; do
        if [[ "$line" =~ ^\+ ]] && check_openai_key "$line"; then
            match=$(echo "$line" | grep -oE "sk-[A-Za-z0-9]{48,}")
            if [ -n "$match" ] && ! is_exception "$line"; then
                report_secret "$file" "OpenAI API Key" "$match"
            fi
        fi
    done <<< "$CONTENT"
done

# Final result
if [ "$SECRETS_FOUND" = true ]; then
    echo ""
    echo -e "${RED}üö® COMMIT BLOCKED: Potential secrets detected!${NC}"
    echo ""
    echo -e "${YELLOW}How to fix:${NC}"
    echo "1. Remove the secret from your code"
    echo "2. Use environment variables instead"
    echo "3. Add to .gitignore if it's a config file"
    echo "4. Use placeholder values in documentation"
    echo ""
    echo -e "${YELLOW}If this is a false positive:${NC}"
    echo "1. Check the exception patterns in .githooks/pre-commit"
    echo "2. Add your pattern to the is_exception function"
    echo "3. Use --no-verify to bypass (NOT recommended)"
    echo ""
    exit 1
else
    echo -e "${GREEN}‚úÖ No secrets detected - commit approved!${NC}"
    exit 0
fi